package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/smtp"
	"strings"
	"time"

	"github.com/datmedevil17/go-vuln/internal/config"
)

type NotificationService struct {
	config *config.Config
}

type SlackMessage struct {
	Text        string       `json:"text"`
	Attachments []Attachment `json:"attachments,omitempty"`
}

type Attachment struct {
	Color  string  `json:"color"`
	Title  string  `json:"title"`
	Text   string  `json:"text"`
	Fields []Field `json:"fields,omitempty"`
}

type Field struct {
	Title string `json:"title"`
	Value string `json:"value"`
	Short bool   `json:"short"`
}

func NewNotificationService(cfg *config.Config) *NotificationService {
	return &NotificationService{config: cfg}
}

// SendScanCompletedEmail sends an email notification when a scan completes
func (s *NotificationService) SendScanCompletedEmail(to, scanType, target, status string) error {
	if !s.config.Email.Enabled {
		return nil // Email disabled
	}

	subject := fmt.Sprintf("VulnPilot: %s Scan Completed - %s", scanType, status)
	body := fmt.Sprintf(`
VulnPilot Security Scan Completed

Scan Type: %s
Target: %s
Status: %s

Please log in to VulnPilot to view detailed results.

---
This is an automated message from VulnPilot.
`, scanType, target, status)

	return s.sendEmail(to, subject, body)
}

// SendWorkflowReport sends a detailed workflow report with AI analysis
func (s *NotificationService) SendWorkflowReport(to, target, status, aiReport string) error {
	if !s.config.Email.Enabled {
		return nil
	}

	subject := fmt.Sprintf("VulnPilot: Security Audit Report - %s", target)
	body := fmt.Sprintf(`
VulnPilot Security Scan & Audit Report

Target: %s
Status: %s
Date: %s

---
EXECUTIVE SUMMARY
---
%s

---
This report was automatically generated by VulnPilot AI.
Please log in to the dashboard for interactive details.
`, target, status, "Today", aiReport)

	return s.sendEmail(to, subject, body)
}

// SendVulnerabilityAlert sends an alert when vulnerabilities are found
func (s *NotificationService) SendVulnerabilityAlert(to, severity, description string, count int) error {
	if !s.config.Email.Enabled {
		return nil
	}

	subject := fmt.Sprintf("VulnPilot: %s Severity Vulnerabilities Detected", severity)
	body := fmt.Sprintf(`
VulnPilot Security Alert

Severity: %s
Vulnerabilities Found: %d
Description: %s

Please review these vulnerabilities immediately in your VulnPilot dashboard.

---
This is an automated security alert from VulnPilot.
`, severity, count, description)

	return s.sendEmail(to, subject, body)
}

// sendEmail sends an email using SMTP
func (s *NotificationService) sendEmail(to, subject, body string) error {
	auth := smtp.PlainAuth("", s.config.Email.User, s.config.Email.Password, s.config.Email.SMTPHost)

	// Normalize line endings to CRLF for SMTP compatibility
	body = strings.ReplaceAll(body, "\r\n", "\n") // normalize first
	body = strings.ReplaceAll(body, "\n", "\r\n")

	// Create headers
	headers := fmt.Sprintf("From: %s\r\n"+
		"To: %s\r\n"+
		"Subject: %s\r\n"+
		"Date: %s\r\n"+
		"MIME-Version: 1.0\r\n"+
		"Content-Type: text/plain; charset=\"utf-8\"\r\n"+
		"\r\n", s.config.Email.From, to, subject, time.Now().Format(time.RFC1123Z))

	msg := headers + body + "\r\n"

	addr := fmt.Sprintf("%s:%d", s.config.Email.SMTPHost, s.config.Email.SMTPPort)
	return smtp.SendMail(addr, auth, s.config.Email.From, []string{to}, []byte(msg))
}

// SendSlackNotification sends a notification to Slack
func (s *NotificationService) SendSlackNotification(message string, attachments []Attachment) error {
	if !s.config.Slack.Enabled || s.config.Slack.WebhookURL == "" {
		return nil // Slack disabled
	}

	slackMsg := SlackMessage{
		Text:        message,
		Attachments: attachments,
	}

	jsonData, err := json.Marshal(slackMsg)
	if err != nil {
		return err
	}

	resp, err := http.Post(s.config.Slack.WebhookURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("slack notification failed: %s", resp.Status)
	}

	return nil
}

// NotifyScanComplete sends notifications via all enabled channels
func (s *NotificationService) NotifyScanComplete(userEmail, scanType, target, status string) error {
	// Send email
	if err := s.SendScanCompletedEmail(userEmail, scanType, target, status); err != nil {
		return fmt.Errorf("email notification failed: %w", err)
	}

	// Send Slack notification
	color := "good"
	if status == "failed" {
		color = "danger"
	}

	attachments := []Attachment{
		{
			Color: color,
			Title: fmt.Sprintf("%s Scan Completed", scanType),
			Fields: []Field{
				{Title: "Target", Value: target, Short: true},
				{Title: "Status", Value: status, Short: true},
			},
		},
	}

	if err := s.SendSlackNotification("Security Scan Completed", attachments); err != nil {
		return fmt.Errorf("slack notification failed: %w", err)
	}

	return nil
}

// NotifyVulnerabilitiesFound sends vulnerability alerts
func (s *NotificationService) NotifyVulnerabilitiesFound(userEmail, scanType string, criticalCount, highCount int) error {
	totalCount := criticalCount + highCount
	if totalCount == 0 {
		return nil // No critical/high vulnerabilities
	}

	severity := "High"
	if criticalCount > 0 {
		severity = "Critical"
	}

	description := fmt.Sprintf("Found %d critical and %d high severity vulnerabilities in %s scan",
		criticalCount, highCount, scanType)

	// Send email
	if err := s.SendVulnerabilityAlert(userEmail, severity, description, totalCount); err != nil {
		return fmt.Errorf("email alert failed: %w", err)
	}

	// Send Slack alert
	attachments := []Attachment{
		{
			Color: "danger",
			Title: "⚠️ Security Vulnerabilities Detected",
			Fields: []Field{
				{Title: "Critical", Value: fmt.Sprintf("%d", criticalCount), Short: true},
				{Title: "High", Value: fmt.Sprintf("%d", highCount), Short: true},
				{Title: "Scan Type", Value: scanType, Short: true},
			},
		},
	}

	if err := s.SendSlackNotification("Vulnerability Alert", attachments); err != nil {
		return fmt.Errorf("slack alert failed: %w", err)
	}

	return nil
}
